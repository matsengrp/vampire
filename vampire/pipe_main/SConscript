from os.path import join
import glob
import json

import nestly
import nestly.scons as ns
import SCons.Script as sc

import common
import tcr_vae

sc.Import('env')
localenv = env.Clone()  # noqa

# ### Paths and data sets ###

data_path = '/fh/fast/matsen_e/data/'
seshadri_path = join(data_path, 'seshadri/data/Adaptive/clinical_cohort/')

DATA = {
    'test': {
        'paths': ['sample_data/02-0249_TCRB.4000.tsv.bz2']
    },
    'one-seshadri': {
        'paths': [join(seshadri_path, '09-0306_TCRB.tsv')]
    },
    'one-seshadri-tb': {
        'paths': [join(seshadri_path, 'TB-1052-2M_TCRB.tsv')]
    },
    'seshadri': {
        'paths': [join(seshadri_path, '02-0249_TCRB.tsv'),
                  join(seshadri_path, '09-0306_TCRB.tsv')]
    },
    'healthy-seshadri': {
        'paths': glob.glob(join(seshadri_path, '[01]*TCRB.tsv'))
    },
    '10-healthy-seshadri': {
        'paths': glob.glob(join(seshadri_path, '[01]*TCRB.tsv'))[:10]
    },
    'merged-healthy-seshadri': {
        'paths': ['/home/matsen/re/vampire/vampire/_ignore/all-seshadri-01-TCRB.tsv']
    }
}


# ### Command-line-flag related ###

def check_mode():
    if localenv['mode'] not in ['mini', 'default']:
        raise Exception(f"Unknown mode '{localenv['mode']}'")


def apply_mode(l):
    """
    Default mode runs everything, and mini mode just runs a single element from the list.
    """
    check_mode()
    if localenv['mode'] == 'mini':
        return [l[0]]
    else:
        return l


def default_params_by_mode():
    """
    Mini mode doesn't train for long.
    """
    params = tcr_vae.TCRVAE.default_params()

    if localenv['mode'] == 'mini':
        params['epochs'] = 5

    return params


def base_dict():
    """
    The dictionary that will be shared by all the nests.

    nseqs: the number of sequences generated by the various programs, and for
    which we evaluate Pvae for on the real data.
    """
    if localenv['mode'] == 'mini':
        return {'nseqs': 2}

    return {'nseqs': 500}


def cluster_execution_string(command):
    """
    Apply this to your scons command string* to get it to execute on the
    cluster.

    *The command string but where $SOURCES is replaced by {sources} and
    $TARGETS is replaced by {targets}.
    """
    script_prefix = command.split()[1]
    return (
        f"python3 execute.py --clusters='{localenv['clusters']}' --script-prefix={script_prefix} "
        f"'$SOURCES' '$TARGETS' '{command}'"
    )


# ### Nests and targets ###

nest = ns.SConsWrap(nestly.Nest(base_dict=base_dict()), alias_environment=localenv)

# Nest: the data set choice, named via data name prepended with `_output_`.
nest.add('data_label', [localenv['data_label']], label_func=lambda p: '_output_' + p)

nest.add_aggregate('summarized_agg', list)
summarized_agg_names = []


@nest.add_target_with_env(localenv)
def olga_generated_tsv(env, outdir, c):
    """
    Generate sequences using OLGA.
    """
    return env.Command(
        join(outdir, 'olga-generated.tsv'),
        [],
        f"scripts/olga-generate.sh {c['nseqs']} $TARGET")[0]


@nest.add_target_with_env(localenv)
def olga_generated(env, outdir, c):
    """
    Convert OLGA TSV to a adaptive CSV.
    """
    return env.Command(
        join(outdir, 'olga-generated.csv'),
        c['olga_generated_tsv'],
        'python3 gene_name_conversion.py olga2adaptive $SOURCE $TARGET')[0]


# Nest: the sample, named by sample name.
nest.add('sample', apply_mode(DATA[localenv['data_label']]['paths']), label_func=common.strip_dirpath_extn)
summarized_agg_names.append('sample')


@nest.add_target_with_env(localenv)
def preprocess(env, outdir, c):
    """
    Run the preprocess_adaptive.py script.
    """
    in_path = c['sample']
    return env.Command(
        join(outdir, common.strip_dirpath_extn(in_path) + '.processed.csv'),
        in_path,
        'python3 preprocess_adaptive.py $SOURCE $TARGET')[0]


@nest.add_target_with_env(localenv, 'split')
@ns.name_targets
def split(env, outdir, c):
    """
    Split the sample evenly into test and train.
    """
    in_path = c['preprocess']
    return 'train', 'test', env.Command([
        join(outdir, common.strip_dirpath_extn(in_path) + '.train.csv'),
        join(outdir, common.strip_dirpath_extn(in_path) + '.test.csv')],
        in_path,
        f"python3 util.py split --test-size {localenv['test_size']} $SOURCE $TARGETS")


@nest.add_target_with_env(localenv)
def test_head(env, outdir, c):
    return env.Command(
        join(outdir, f"test.{c['nseqs']}.csv"),
        c['split']['test'],
        f"cut -f 2-4 -d, $SOURCE | head -n {c['nseqs']+1} > $TARGET")[0]


@nest.add_target_with_env(localenv)
def test_pgen(env, outdir, c):
    return env.Command(
        common.strip_extn(c['test_head'])+'.pgen.csv',
        c['test_head'],
        'scripts/olga-pgen.sh $SOURCE $TARGET')[0]


def numerical_nest_add(nest_name, number_list):
    """
    Add an nest for a list of non-negative numbers, with nice zero-padded
    directory names.
    """
    nest.add(nest_name, apply_mode(number_list), label_func=common.zero_pad_list_func(number_list))


# Nest: the model.
nest.add('model', apply_mode([common.strip_dirpath_extn(m) for m in glob.glob('../models/*.py')]))
summarized_agg_names.append('model')

# # Nest: the dimension of the latent space.
# numerical_nest_add('latent_dim', [30, 35, 40])

# # Nest: the number of dense nodes.
# numerical_nest_add('dense_nodes', [50, 100, 150, 200])

# # Nest: the amino acid embedding dimension.
# numerical_nest_add('aa_embedding_dim', [10, 15, 20, 21])

# # Nest: the V gene embedding dimension.
# numerical_nest_add('v_gene_embedding_dim', [20, 30, 40])

# Nest: the strength of the KL component of the VAE loss.
numerical_nest_add('beta', [2.**i for i in range(-4, 4, 2)])
summarized_agg_names.append('beta')


@nest.add_target_with_env(localenv)
def model_params(env, outdir, c):
    """
    Write out a file with parameters from which we can build our VAE.
    """

    # Copy over any relevant parameters from c into the params dictionary.
    params = default_params_by_mode()
    for k, v in c.items():
        if k in params:
            params[k] = v

    return env.Command(
        join(outdir, 'model_params.json'),
        [],
        f"echo '{json.dumps(params)}' > $TARGET")[0]


@nest.add_target_with_env(localenv, 'trained')
@ns.name_targets
def trained(env, outdir, c):
    return 'weights', 'diagnostics', env.Command(
        [join(outdir, 'best_weights.h5'), join(outdir, 'diagnostics.csv')], [c['model_params'], c['split']['train']],
        cluster_execution_string('tcr-vae train {sources} {targets}'))


@nest.add_target_with_env(localenv)
def loss(env, outdir, c):
    return env.Command(
        join(outdir, 'loss.csv'),
        [c['model_params'], c['trained']['weights'], c['split']['train'], c['split']['test']],
        'tcr-vae loss $SOURCES $TARGET')[0]


@nest.add_target_with_env(localenv)
def test_pvae(env, outdir, c):
    return env.Command(
        join(outdir, common.strip_dirpath_extn(c['test_head'])+'.pvae.csv'),
        [c['model_params'], c['trained']['weights'], c['test_head']],
        cluster_execution_string('tcr-vae pvae {sources} {targets}'))[0]


@nest.add_target_with_env(localenv)
def vae_generated(env, outdir, c):
    return env.Command(
        join(outdir, 'generated.csv'),
        [c['model_params'], c['trained']['weights']],
        f"tcr-vae generate --nseqs {c['nseqs']} $SOURCES $TARGET")[0]


@nest.add_target_with_env(localenv)
def vae_generated_pgen(env, outdir, c):
    return env.Command(
        common.strip_extn(c['vae_generated'])+'.pgen.csv',
        c['vae_generated'],
        'scripts/olga-pgen.sh $SOURCE $TARGET')[0]


@nest.add_target_with_env(localenv)
def olga_generated_pvae(env, outdir, c):
    return env.Command(
        join(outdir, common.strip_dirpath_extn(c['olga_generated'])+'.pvae.csv'),
        [c['model_params'], c['trained']['weights'], c['olga_generated']],
        cluster_execution_string('tcr-vae pvae {sources} {targets}'))[0]


@nest.add_target_with_env(localenv)
def summarized(env, outdir, c):
    summarized = join(outdir, 'summarized.csv')
    c['summarized_agg'].append((summarized, c))
    to_pass = ['loss', 'test_pvae', 'test_pgen', 'vae_generated_pgen']
    colnames = ','.join(to_pass)
    idx = ';'.join([str(c[k]) for k in summarized_agg_names])
    idx_name = ';'.join(summarized_agg_names)
    return env.Command(
        summarized,
        [c[k] for k in to_pass],
        f'python3 util.py summarize --out $TARGET --idx "{idx}" --idx-name "{idx_name}" --colnames {colnames} $SOURCES'
    )[0]


for nest_name in reversed(summarized_agg_names):
    nest.pop(nest_name)


@nest.add_target_with_env(localenv)
def aggregate_summarized(env, outdir, c):
    return env.Command(
        join(outdir, 'aggregated.csv'),
        [s for (s, _) in c['summarized_agg']],
        'python3 util.py stackrows --out $TARGET $SOURCES')[0]
